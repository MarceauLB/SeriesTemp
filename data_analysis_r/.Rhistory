density(Z)
dist_exp <- rexp(191,hat_lambda)
dist_exp
dist_exp <- rexp(191,hat_lambda)
sequence <- seq(from=-0.5,to=4,length.out=50)
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 1)
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 0.8)
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 0.8)
#5.
par(mfrow=c(2,1))
acf(1:nrow(coal),lag.max = 100)
acf(Z,lag.max = 100)
#5.
par(mfrow=c(2,1))
acf(1:nrow(coal),lag.max = 100)
acf(1:nrow(coal),lag.max = 100)
acf(1:nrow(coal),lag.max = 100)
acf(Z,lag.max = 100)
#6.
#a.
par(mfrow=c(1,1))
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
s_opt
abline(v=s_opt,col="red")
print(s_index)
for(s_index in seq_along(s_grid)){
print(s_index)
}
#b.
mlestimator <- function(s_grid){
res<- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
print(s_index)
}
}
for(s_index in seq_along(s_grid)){
print(s_index)
}
#b.
mlestimator <- function(s_grid){
lamb_past <- numeric(length(s_grid))
lamb_post <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past <- Z[1:s]
x_post <- Z[(s+1):length(Z)]
lamb_past[s_index] <- 1/mean(x_past)
lamb_post[s_index] <- 1/mean(x_post)
}
out <- list(lamb_past=lamb_past,
lamb_post=lamb_post)
return(out)
}
mlest <- mlestimator(s_grid)
mlest
plot(mlest$lamb_past)
#3.
mean(Z) # une explosition tous les semestres en moyenne
hat_lambda <- 1/(mean(Z)) # Par estimation MLE #paramètres de la loi exponentielle
hat_lambda
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
mlest <- mlestimator(s_grid)
mlest
plot(mlest$lamb_past)
points(mlest$lamb_post)
plot(mlest$lamb_post)
point(mlest$lamb_post)
plot(mlest$lamb_past)
point(mlest$lamb_post)
rm(list=ls())
par(mfrow=c(1,1))
library(SMPracticals)
#1.
X <- 1:nrow(coal)
plot(coal$date,X,main="Nb de mort",type="line")
#2.
Z <- diff(coal$date)
Z
plot(Z)
plot(Z,type="l")
#3.
mean(Z) # une explosition tous les semestres en moyenne
hat_lambda <- 1/(mean(Z)) # Par estimation MLE #paramètres de la loi exponentielle
#4.
dens_Z <- density(Z)
dist_exp <- rexp(191,hat_lambda)
sequence <- seq(from=-0.5,to=4,length.out=50)
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 0.8)
#5.
par(mfrow=c(2,1))
acf(1:nrow(coal),lag.max = 100) # série correlé
acf(Z,lag.max = 100) # série décorrelé
#6.
#a.
par(mfrow=c(1,1))
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
#b.
mlestimator <- function(s_grid){
lamb_past <- numeric(length(s_grid))
lamb_post <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past <- Z[1:s]
x_post <- Z[(s+1):length(Z)]
lamb_past[s_index] <- 1/mean(x_past)
lamb_post[s_index] <- 1/mean(x_post)
}
out <- list(lamb_past=lamb_past,
lamb_post=lamb_post)
return(out)
}
mlest <- mlestimator(s_grid)
plot(mlest$lamb_past)
point(mlest$lamb_post)
#g.
#g.
#g.
#g.
#g.
#g.
plot(s_grid, mlest$lamb_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s")
points(s_grid, mlest$lamb_post, type = "b", col = "red")
legend("topright", legend = c("Lambda Past", "Lambda Post"), col = c("blue", "red"), lty = 1, cex = 0.8)
plot(s_grid, mlest$lamb_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s",
ylim=c(min(mlest$lamb_past,mlest$lamb_post),max(mlest$lamb_past,mlest$lamb_post)))
points(s_grid, mlest$lamb_post, type = "b", col = "red")
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
s_opt
mlest$lamb_past
mlest$lamb_past[s_opt]
mlest$lamb_post[s_opt]
mlest$lamb_past[s_opt]
mlest$lamb_post[s_opt]
#1.
X <- 1:nrow(coal)
plot(coal$date,X,main="Nb de mort",type="line")
#2.
Z <- diff(coal$date)
Z
plot(Z)
plot(Z,type="l")
#2.
Z <- diff(coal$date)
Z
plot(Z)
plot(Z,type="l")
#1.
X <- 1:nrow(coal)
plot(coal$date,X,main="Nb de mort",type="line")
#2.
Z <- diff(coal$date)
Z
plot(Z)
plot(Z,type="l")
#3.
mean(Z) # une explosition tous les semestres en moyenne
hat_lambda <- 1/(mean(Z)) # Par estimation MLE #paramètres de la loi exponentielle
hat_lambda
#4.
dens_Z <- density(Z)
dist_exp <- rexp(191,hat_lambda)
sequence <- seq(from=-0.5,to=4,length.out=50)
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 0.8)
#5.
par(mfrow=c(2,1))
acf(1:nrow(coal),lag.max = 100) # série correlé
acf(Z,lag.max = 100) # série décorrelé
#6.
#a.
par(mfrow=c(1,1))
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
#b.
mlestimator <- function(s_grid){
lamb_past <- numeric(length(s_grid))
lamb_post <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past <- Z[1:s]
x_post <- Z[(s+1):length(Z)]
lamb_past[s_index] <- 1/mean(x_past)
lamb_post[s_index] <- 1/mean(x_post)
}
out <- list(lamb_past=lamb_past,
lamb_post=lamb_post)
return(out)
}
plot(s_grid, mlest$lamb_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s",
ylim=c(min(mlest$lamb_past,mlest$lamb_post),max(mlest$lamb_past,mlest$lamb_post)))
points(s_grid, mlest$lamb_post, type = "b", col = "red")
legend("topright", legend = c("Lambda Past", "Lambda Post"), col = c("blue", "red"), lty = 1, cex = 0.8)
mlest$lamb_past[s_opt]
mlest$lamb_post[s_opt]
rm(list=ls())
par(mfrow=c(1,1))
library(SMPracticals)
#1.
X <- 1:nrow(coal)
plot(coal$date,X,main="Nb de mort",type="line")
#2.
Z <- diff(coal$date)
Z
plot(Z)
plot(Z,type="l")
#3.
mean(Z) # une explosition tous les semestres en moyenne
hat_lambda <- 1/(mean(Z)) # Par estimation MLE #paramètres de la loi exponentielle
#4.
dens_Z <- density(Z)
dist_exp <- rexp(191,hat_lambda)
sequence <- seq(from=-0.5,to=4,length.out=50)
plot(dens_Z,ylim=c(0,1.7),xlim=c(-0.2, 4))
lines(density(dist_exp),col="red")
lines(sequence,dexp(sequence,hat_lambda),col="blue")
legend("topright",legend = c("Data", "rexp","dexp"),
col = c("black", "red","blue"),
lty = 1, cex = 0.8)
#5.
par(mfrow=c(2,1))
acf(1:nrow(coal),lag.max = 100) # série correlé
acf(Z,lag.max = 100) # série décorrelé
#6.
#a.
par(mfrow=c(1,1))
s_grid <- 10:180
log_lik <- function(s_grid){
res <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past = Z[1:s]
x_post = Z[(s+1):length(Z)]
lambda1 <- 1/mean(x_past)
lambda2 <- 1/mean(x_post)
res[s_index] <- sum(dexp(x_past, lambda1, log=TRUE)) + sum(dexp(x_post, lambda2, log=TRUE))
}
return(res)
}
out_log_lik <- log_lik(s_grid)
plot(s_grid,out_log_lik)
s_opt <- s_grid[which(max(out_log_lik)==out_log_lik)]
abline(v=s_opt,col="red")
#b.
mlestimator <- function(s_grid){
lamb_past <- numeric(length(s_grid))
lamb_post <- numeric(length(s_grid))
for(s_index in seq_along(s_grid)){
s <- s_grid[s_index]
x_past <- Z[1:s]
x_post <- Z[(s+1):length(Z)]
lamb_past[s_index] <- 1/mean(x_past)
lamb_post[s_index] <- 1/mean(x_post)
}
out <- list(lamb_past=lamb_past,
lamb_post=lamb_post)
return(out)
}
plot(s_grid, mlest$lamb_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s",
ylim=c(min(mlest$lamb_past,mlest$lamb_post),max(mlest$lamb_past,mlest$lamb_post)))
mlest <- mlesstimator(s_grid)
mlest <- mlestimator(s_grid)
mlest
mle_post <- mlest$lamb_post
mle_past <- mlest$lamb_past
mle_past <- mlest$lamb_past
mle_post <- mlest$lamb_post
plot(s_grid, mle_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s",
ylim=c(min(mlest$lamb_past,mlest$lamb_post),max(mlest$lamb_past,mlest$lamb_post)))
plot(s_grid, mle_past, type = "b", col = "blue",
ylab = "Lambda", xlab = "s", main = "Lambda Estimates for Different s",
ylim=c(min(mle_past,mle_post),max(mle_past, mle_post)))
points(s_grid, mlest$lamb_post, type = "b", col = "red")
points(s_grid, mle_post, type = "b", col = "red")
legend("topright", legend = c("Lambda Past", "Lambda Post"), col = c("blue", "red"), lty = 1, cex = 0.8)
#c.
mle_past$lamb_past[s_opt]
#c.
mle_past[s_opt]
abline(v=s_opt)
#c.
mle_past[s_opt]
mle_post[s_opt]
#c.
mle_past[s_opt]
mle_post[s_opt]
#d.
plot(coal$date,X)
#d.
plot(coal$date,X,main="Nb de mort",type="line")
abline(v=s_opt)
#d.
plot(coal$date,X,main="Nb de mort",type="line")
abline(v=s_opt)
#d.
plot(coal$date,X,main="Nb de mort",type="l")
abline(v=s_opt)
plot(coal$date,X,main="Nb de mort",type="l")
#1.
X <- 1:nrow(coal)
plot(coal$date,X,main="Nb de mort",type="l")
#d.
plot(X,main="Nb de mort",type="l")
#d.
plot(Z,X,main="Nb de mort",type="l")
#d.
plot(c(0,Z),X,main="Nb de mort",type="l")
#d.
plot(X,c(0,Z),main="Nb de mort",type="l")
abline(v=s_opt)
plot(Z)
plot(Z,type="l")
#d.
plot(Z)
#d.
plot(Z,type="l")
abline(v=s_opt,col="red")
rm(list=ls())
#1.
rinhomo <- function(T_period,lamb,beta){
M <- lamb + abs(beta)
process <- c()
t <- 0
while(t<T_period){
e <- rexp(1,M)
t <- t + e
u <- runif(1,0,M)
if((t < T_period)&(u<(lamb + beta*sin(t)))){
process <- c(process, t)
}
}
return(process)
}
#2. # compensateur pour le test
transform_LAMBDA <- function(res_rinhomo,lamb,beta){
res <- numeric(length(res_rinhomo))
for(i in 1:(length(res_rinhomo))){
res[i] <- lamb*res_rinhomo[i] + beta*(1-cos(res_rinhomo[i]))
}
return(res)
}
setwd("~/00_Ensai/serie_temporelle/SeriesTemp/data_analysis_r/")
# Author: Alexandre Maghames
# Clear the environment
rm(list=ls())
# Load libraries
library(quantmod)
library(tseries)
library(forecast)
library(evd)
# Set Seed
set.seed(13012025)
# Define the ticker symbol
ticker <- "GOOGL"
start_date <- "2007-01-01"
end_date <- "2024-12-31"
#Import data
getSymbols(ticker, src = "yahoo",from=start_date,to=end_date)
# Focus Open
ts_serie <- ts(GOOGL$GOOGL.Open)
plot(ts_serie)
adf.test(ts_serie)
# H0 : la série est non stationnaire
# H1 : la série est stationnaire
# p-valeur à 0.9782 : on ne peut pas rejetter H0.
# La série n'est pas stationnaire
acf(ts_serie)
pacf(ts_serie)
# on va travailler sur la log(serie)
log_ts <- log(ts_serie)
plot(log_ts)
adf.test(log_ts)
# p-val 0.056. On ne peut pas rejetter H0. La série est non stationnaire
# on la différencie
serie_diff <- diff(log_ts)
plot(serie_diff)
adf.test(serie_diff)
# p-val à 0.01. La série semble être stationnarisé.
acf(serie_diff,lag.max = 100)
pacf(serie_diff,lag.max = 100)
res <- auto.arima(log_ts)
res
ts_serie
plot.ts(GOOGL$GOOGL.Open)
plot(GOOGL$GOOGL.Open)
plot(GOOGL$GOOGL.Open,col="salmon2")
setwd("~/00_Ensai/serie_temporelle/SeriesTemp/data_analysis_r/")
# Set Seed
set.seed(13012025)
# Define the ticker symbol
ticker <- "GOOGL"
# Dates
start_date <- "2007-01-01"
end_date <- "2024-12-31"
# Import data
getSymbols(ticker, src = "yahoo",from=start_date,to=end_date)
# Focus on Open Prices
google_open_prices = GOOGL$GOOGL.Open
ts_serie <- ts(google_open_prices)
plot(ts_serie, main = "Initial time series of Google opening prices", col = "darkblue")
plot(google_open_prices, main = "Initial time series of Google opening prices", col = "darkblue")
plot(google_open_prices, main = "Initial time series of Google opening prices", col = "darkblue")
